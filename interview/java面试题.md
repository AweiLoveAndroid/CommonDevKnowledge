# java面试题汇总

熟练掌握java是很关键的，大公司不仅仅要求你会使用几个api，更多的是要你熟悉源码实现原理，甚至要你知道有哪些不足，怎么改进，还有一些java有关的一些算法，设计模式等等。

### 一、java基础面试知识点

* java中==和equals和hashCode的区别
**答：**==是运算符，用于比较两个变量是否相等。
equals，是Objec类的方法，用于比较两个对象是否相等，默认Object类的equals方法是比较两个对象的地址，跟==的结果一样。
hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。（HashMap，HashSet等）

* int、char、long各占多少字节数
**答：** byte 1个字节，short 2个字节，char 2个字节，int 4个字节，long 8个字节，float 4个字节，double 8个字节，boolen 1个字节

* int与integer的区别
**答：**1、Integer是int的包装类，int则是java的一种基本数据类型
2、Integer变量必须实例化后才能使用，而int变量不需要
3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 
4、Integer的默认值是null，int的默认值是0

* 谈谈对java多态的理解
**答：**多态的存在有三个前提:
1.要有继承关系
2.子类要重写父类的方法
3.父类引用指向子类
多态成员访问的特点：
成员变量
编译看左边(父类),运行看左边(父类)
成员方法
编译看左边(父类)，运行看右边(子类)。动态绑定
静态方法
编译看左边(父类)，运行看左边(父类)。
(静态和类相关，算不上重写，所以，访问还是左边的)
只有非静态的成员方法,编译看左边,运行看右边 

* String、StringBuffer、StringBuilder区别
**答：**String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

* 什么是内部类？内部类的作用
**答：**内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。
内部类的主要作用如下：
1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便

* 抽象类和接口区别
**答：**抽象类只能单继承,接口能多实现。
抽象类是一个类,可以被任意权限修饰符修饰,静态和非静态属性，final和非final属性，可以有抽象方法和非抽象方法；
接口只能被public,final修饰,只能有抽象方法,即使没有显示的声明，而且是不可修改的；
抽象的事物不同:
抽象类是对类的抽象,接口是对行为的抽象；
抽象类是对整个类抽象,包括属性,行为；
接口是对类的行为(局部)进行抽象；
定义的时候,定义抽象类和接口的思想不同：
设计抽象类是自下而上的过程,子类需要,所以我定义抽象类；
设计接口是自上而下的过程,接口规范某一行为,某类需要这个行为,我实现某接口；
核心区别:
调用者使用动机不同,实现接口是为了使用他规范的某一个行为；
继承抽象类是为了使用这个类属性和行为.

* 抽象类的意义
**答：**更利于代码的维护和重用

* 抽象类与接口的应用场景
**答：**接口是为了使用他规范的某一个行为
抽象类是为了使用这个类属性和行为

* 抽象类是否可以没有方法和属性？
**答：**可以

* 接口的意义
**答：**实现接口是为了使用他规范的某一个行为；多态

* 泛型中extends和super的区别
**答：**泛型中extends表示上界通配符，super表示下届通配符
频繁往外读取内容的，适合用上界Extends。
经常往里插入的，适合用下界Super。

* 父类的静态方法能否被子类重写
**答：**不能，静态方法只和类有关，和对象无关。

* 进程和线程的区别
**答：**进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。
线程是进程的一个实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

* final，finally，finalize的区别
**答：**Final用于修饰类、成员变量和成员方法。
Finally通常和try catch搭配使用，保证不管有没有发生异常，资源都能够被释放。
Finalize是object类中的一个方法，子类可以重写finalize()方法实现对资源的回收。

* 序列化的方式
**答：**Json,Serializable,Parcelable,ObjectOutputStream

* Serializable 和Parcelable 的区别
**答：**S是java api，P是Android api;
S过程需要大量的I/O操作，开销大，
P过程不需要大量的I/O操作，开销小；
S效率低，P效率高；

* 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？
答：java中静态属性和静态方法可以被继承，但是没有被重写(overwrite)而是被隐藏。
静态方法和属性是属于类的。

* 静态内部类的设计意图
**答：**静态内部类可以独立存在，又希望只被外部类使用，private秀时候不被同一个包下的其他类使用。
非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。
静态内部类的作用：
只是为了降低包的深度，方便类的使用，
静态内部类适用于包含类当中，但又不依赖与外在的类，不能使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。
在创建静态内部类的时候，不需要外部类对象的引用。
非静态内部类有一个很大的优点：可以自由使用外部类的所有变量和方法

* 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用
**答：**1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，
2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。
3.方便编写事件驱动程序
4.方便编写线程代码

* 谈谈对kotlin的理解
**答：**代码的大幅度精简
100% 兼容 Java 代码
函数式编程
各种语法糖

* 闭包和局部内部类的区别
**答：**局部内部类要求外部环境持有的自由变量必须是final的

* string 转换成 integer的方式及原理
**答：**Integer.valueOf()，
首先会调用parseInt()方法，把String类型转化成int,其中大致分为
1.参数有效性检验
2.进制有效性检验
3.正负符号判断
4.循环变量每一个字符，判断是否是有效字符（可以转化成数字），合计结果会不会溢出
5.判断是否在Integer缓存池中[-128, 127]，如果不是则重新创建。

### 二、java深入源码级的面试题（有难度）

* 哪些情况下的对象会被垃圾回收机制处理掉？
**答：**当系统空闲，或者内存紧张，系统调用gc，从gc root对象开始搜索不可达的对象。（一般问题会深入，不会就这么简单打完）
1.引用计数算法
2.根搜索算法（java 采用）
###### 哪些对象可以作为GC Roots？
虚拟机栈（栈帧中的本地变量表）中的引用的对象
方法区中的类静态属性引用的对象
方法区中的常量引用的对象
本地方法栈中JNI（Native方法）的引用对象
###### 判断了对象生死，怎么进行内存的清理呢？
1.标记清除算法：先标记那些要被回收的对象，然后进行清理，但是效率低，因为要一个一个标记和清除，造成大量不连续的内存碎片。
2.复制收集算法：将可用内存按照容量分为大小相等的两块，每次只是使用其中的一块。当这一块的内存用完了，就将可用内存中存活着的对象复制到另一块上，并清除已使用过的内存空间。（java 采用）
JVM将堆分为新生代和老年代，新生代又有Eden,Servivor0,Servivor1，当Eden区满的时候引发minor gc，把存活的对象移到Servivor0；当Servivor0满
的时候，把存活的对象移到Servivor1；当Servivor1满的时候，把存活的对象转移到老年代；当老年代满的时候引发full gc。

* 讲一下常见编码方式？
**答：**[点这里](http://blog.csdn.net/lengdetianxia2010/article/details/71125647)
ASCII码：共128个，用一个字节的低7位表示。
ISO8859-1：在ASCII码的基础上涵盖了大多数西欧语言字符，仍然是单字节编码，它总共能表示256个字符。
GB2312：它是双字节编码，总的编码范围是A1~F7。A1~A9 符号区，B0~F7 汉字区
GBK：扩展了GB2312，加入更多的汉字，它的编码范围是8140~FEFE（去掉XX7F），与GB2312兼容
GB18030：它可能是单字节、双字节或者四字节编码，与GB2312编码兼容
UTF-16：具体定义了Unicode字符在计算机中的存取方法。采用2字节来表示Unicode转化格式，它是定长的表示方法，不论什么字符都可以用两个字节表示
UTF-8：采用一种变长技术，每个编码区域有不同的字码长度，不同的字符可以由1~6个字节组成。
编码规则如下：
如果一个字节，最高位为0，表示这是一个ASCII字符（00~7F）
如果一个字节，以11开头，连续的1的个数暗示这个字符的字节数 
如果一个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节

* utf-8编码中的中文占几个字节；int型几个字节？
**答：**一个utf8数字占1个字节
一个utf8英文字母占1个字节
少数是汉字每个占用3个字节，多数占用4个字节

* 静态代理和动态代理的区别，什么场景使用？
**答：**

* Java的异常体系
**答：**Throwable是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常，  这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。
1、Error与Exception
Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。
Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。
2、运行时异常和非运行时异常
运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。
###### 异常的捕获和处理
try catch finally

* 谈谈你对解析与分派的认识。
**答：**[看这里](http://blog.csdn.net/u011080472/article/details/51334288)

* 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？
**答：**难道不是Key的equals方法？如果A对象是key的话，是Object的equals的方法

* Java中实现多态的机制是什么？
**答：**重写：子类对父类抽象方法的覆盖实现多态
1.继承
2.子类复写父类方法
3.父类引用指向子类对象
重载：同一个类中定义多个同名的不同方法来实现多态

* 如何将一个Java对象序列化到文件里？
**答：**ObjectOutputStream，或者json

* 说说你对Java反射的理解
**答：**JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
###### 优点：
能够运行时动态获取类的实例，大大提高系统的灵活性和扩展性。 
与Java动态编译相结合，可以实现无比强大的功能 
###### 缺点：
使用反射的性能较低 
使用反射相对来说不安全 
破坏了类的封装性，可以通过反射获取这个类的私有方法和属性 

* 说说你对Java注解的理解
**答：**注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。
作用分类：
编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】
代码分析：通过代码里标识的元数据对代码进行分析【使用反射】
编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】

* 说说你对依赖注入的理解
**答：**依赖注入用于解耦。模块A需要一个实现了接口IB的类来负责一部分功能，现在在A中new了BImpl类，但是现在A不仅仅依赖了IB这个接口，还依赖了他的具体实现类BImpl；如何后期需要替换BImpl2为具体实现，那么就需要修改到A中的代码，代码就耦合了。所以我们需要依赖注入来降低这种耦合。
###### 依赖注入的方式：
构造函数注入
setter注入
接口注入
注解注入

* 说一下泛型原理，并举例说明
**答：**

* Java中String的了解
**答：**String类是final类，也即意味着String类不能被继承
String类其实是通过char数组来保存字符串的
String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象

* String为什么要设计成不可变的？
**答：**字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。
JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。
假若字符串对象允许改变,那么两个变量同时指向同一个字符串的变量就会发生逻辑错误，改变一个对象会影响到另一个。

* Object类的equal和hashCode方法重写，为什么？
**答：**为了保证对象在equals相同的情况下hashcode值必定相同。
HashMap中添加一对键值对，会先判断Key的hashcode的值是否一样，如果一致再进一步判断equals方法。
如果不重写hashcode方法会出现，equals一致，hashcode值不一致的情况，从而认为Key不一致，但事实上开发认为是相同的Key。

### 三、数据结构

* 常用数据结构简介
**答：**数组：顺序存储，随机访问
链表：链表存储，顺序访问
栈
队列
串
树

* 并发集合了解哪些？
**答：**
###### 并发List
Vector和CopyOnWriteArrayList是两个线程安全的List，Vector读写操作都用了同步，相对来说更适用于写多读少的场合，CopyOnWriteArrayList在写的时候会复制一个副本，对副本写，写完用副本替换原值，读的时候不需要同步，适用于写少读多的场合。
###### 并发Set
CopyOnWriteArraySet基于CopyOnWriteArrayList来实现的，只是在不允许存在重复的对象这个特性上遍历处理了一下。
###### 并发Map
ConcurrentHashMap是专用于高并发的Map实现，内部实现进行了锁分离，get操作是无锁的。
###### 并发Queue
在并发队列上JDK提供了两套实现，一个是以ConcurrentLinkedQueue为代表的高性能队列，一个是以BlockingQueue接口为代表的阻塞队列。ConcurrentLinkedQueue适用于高并发场景下的队列，通过无锁的方式实现，通常ConcurrentLinkedQueue的性能要优于BlockingQueue。BlockingQueue的典型应用场景是生产者-消费者模式中，如果生产快于消费，生产队列装满时会阻塞，等待消费。
###### 并发Dueue
Queue是一种双端队列，它允许在队列的头部和尾部进行出队和入队的操作。Dueue实现类有非线程安全的LinkedList、ArrayDueue和线程安全的LinkedBlockingDueue。LinkedBlockingDueue没有进行读写锁的分离，因此同一时间只能有一个线程对其操作，因此在高并发应用中，它的性能要远远低于LinkedBlockingQueue，更低于ConcurrentLinkedQueue。

* 列举java的集合以及集合之间的继承关系
**答：**
##### Collection
###### List，List 接口继承 Collection，允许重复，维护元素插入顺序
ArrayList 底层数据结构是数组，查询快，增删慢
LinkedLsit 底层数据结构是链表，查询慢，增删快
Vector 线程同步，底层数据结构是数组，效率低
###### Set，Set 接口继承 Collection，集合元素不重复
HashSet 由HashMap实现的，唯一，不保证元素的顺序，允许null键，null值
子类LinkedHashSet
TreeSet 有序，底层基于TreeMap实现，线程不安全
##### Map，Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value
Hashtable
HashMap 子类LinkedHashMap 内部维护双向链表
TreeMap 可以用于排序

* 集合类以及集合框架
**答：**同上

* 容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 [Java容器类](http://alexyyek.github.io/2015/04/06/Collection/)）
* List,Set,Map的区别
**答：**

* List和Map的实现方式以及存储方式
**答：**

* HashMap的实现原理
**答：**数组加链表，每个数组存放Key的hashCode被hash方法处理后值相同的元素的链表。

* HashMap数据结构？
**答：**

* HashMap源码理解
**答：**

* HashMap如何put数据（从HashMap源码角度讲解）？
**答：**根据Key的hashCode调用hash方法计算hash值，
根据hash值计算桶（hash对应的链表）的在数组中的位置，
如果桶不为空，则遍历链表查找是否Key已经存在如果存在则替换原值，如果不存在则添加到链表尾处，
如果桶为空，则新建节点直接添加。

* HashMap怎么手写实现？
**答：**

* ConcurrentHashMap的实现原理
**答：**与HashMap类似，只是在put的时候每个桶上加了同步锁，并且每个节点的value和next用volatile修饰保证可见性。

* ArrayMap和HashMap的对比
**答：**存储方式不同：ArrayMap内部使用两个数组，一个存HashCode，一个存键值对对象。HashMap内部是Entry对象
扩容方式不同：HashMap初始大小是16，达到满容量的0.75时，要扩容，每次都是上次容量的2倍。而ArrayMap是
如果size长度大于8时申请size*1.5个长度，大于4小于8时申请8个，小于4时申请4个。
插入性能：如果是顺序插入ArrayMap效率高，否则HashMap效率高
查找性能：HashMap高

* HashTable实现原理
**答：**原理基本上和HashMap一致，只是在各个方法上有Synchronized进行同步。

* TreeMap具体实现
**答：**底层是红黑树，有序


* HashMap和HashTable的区别
**答：**HashMap线程不安全，效率高，允许null键null值
Hashtable线程安全，效率低，不允许null键null值

* HashMap与HashSet的区别
**答：**HashMap实现了Map接口，HashSet实现了Set接口
HashSet以对象作为元素,而HashMap以(key-value)的一组对象作为元素
HashSet内部就是使用HashMap实现的，和HashMap不同的是它不需要Key和Value两个值

* HashSet与HashMap怎么判断集合元素重复？
**答：**根据Key的hashCode调用hash方法计算hash值，
根据hash值计算桶（hash对应的链表）的在数组中的位置，
如果桶不为空，则遍历链表查找是否Key已经存在(比较hash值，地址值，equals方法)如果存在则替换原值，如果不存在则添加到链表尾处，
如果桶为空，则新建节点直接添加。

* 集合Set实现Hash怎么防止碰撞
**答：**底层使用了HashMap,计算hash(根据key的hashCode重新计算一次散列，hashCode的高16位异或低16位)

* ArrayList和LinkedList的区别，以及应用场景
* 数组和链表的区别
**答：**数组查询快，增删慢
链表查询慢，增删快

* 二叉树的深度优先遍历和广度优先遍历的具体实现
**答：**
~~~ java
// 递归实现二叉树的先序遍历
public static void preOrder(Node node) {
    if (node != null) {
        print(node);
        preOrder(node.left);
        preOrder(node.right);
    }
}
// 递归实现二叉树的中序遍历
public static void inOrder(Node node) {
    if (node != null) {
        inOrder(node.left);
        print(node);
        inOrder(node.right);
    }
}
// 递归实现二叉树的后序遍历
public static void postOrder(Node node) {
    if (node != null) {
        postOrder(node.left);
        postOrder(node.right);
        print(node);
    }
}
//二叉树广度优先遍历——层序遍历
public static void layerTraversal(Node root) {
    Queue<Node> queue = new LinkedList<>();
    if (root != null) {
        queue.add(root);
        while (!queue.isEmpty()) {
            Node currentNode = queue.poll();
            print(currentNode);
            if (currentNode.left != null) {
                queue.add(currentNode.left);
            }
            if (currentNode.right != null) {
                queue.add(currentNode.right);
            }
        }
    }
}
~~~
[看这里](https://www.cnblogs.com/gl-developer/p/7259251.html)

* 堆的结构
**答：**完全二叉树，每个节点都大（小）于它的两个子节点，当每个节点都大于等于它的两个子节点时，就称为大顶堆，也叫堆有序； 当每个节点都小于等于它的两个子节点时，就称为小顶堆。
堆排序思想(以大顶堆为例)：
1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆
2.将根节点与尾节点交换并输出此时的尾节点
3.将剩余的n -1个节点重新进行堆有序化 
4.重复步骤2，步骤3直至构造成一个有序序列

* 堆和树的区别
**答：**
###### 简答:
1.堆是完全二叉树，树不一定。
2.深度不一致二叉树最好情况下其深度为log n（表示以2为底的对数），最坏情况下其深度为n；堆的深度即为堆所对应的完全二叉树的深度log n
3.堆只是限定了某结点的值大于（或小于）其左右孩子结点的值，但没有限定左右孩子结点之间的大小关系。
###### 这里就用二叉排序树和大顶堆来说区别：
1.在二叉排序树中，每个结点的值均大于其左子树上所有结点的值，小于其右子树上所有结点的值，对二叉排序树进行中序遍历得到一个有序序列。所以，二叉排序树是结点之间满足一定次序关系的二叉树；
堆是一个完全二叉树，并且每个结点的值都大于或等于其左右孩子结点的值（这里的讨论以大根堆为例），所以，堆是结点之间满足一定次序关系的完全二叉树。
2.具有n个结点的二叉排序树，其深度取决于给定集合的初始排列顺序，最好情况下其深度为log n（表示以2为底的对数），最坏情况下其深度为n；
具有n个结点的堆，其深度即为堆所对应的完全二叉树的深度log n
3.在二叉排序树中，某结点的右孩子结点的值一定大于该结点的左孩子结点的值；在堆中却不一定，堆只是限定了某结点的值大于（或小于）其左右孩子结点的值，但没有限定左右孩子结点之间的大小关系。
4.在二叉排序树中，最小值结点是最左下结点，其左指针为空；最大值结点是最右下结点，其右指针为空。在大根堆中，最小值结点位于某个叶子结点，而最大值结点是大根堆的堆顶（即根结点）。
5.二叉排序树是为了实现动态查找而设计的数据结构，它是面向查找操作的，在二叉排序树中查找一个结点的平均时间复杂度是O(log n)；
堆是为了实现排序而设计的一种数据结构，它不是面向查找操作的，因而在堆中查找一个结点需要进行遍历，其平均时间复杂度是O(n)。

* 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？
**答：**
1、应用程序所有的部分都使用堆内存，然后栈内存通过一个线程运行来使用。
2、不论对象什么时候创建，他都会存储在堆内存中，栈内存包含它的引用。栈内存只包含原始值变量和堆中对象变量的引用。
3、存储在堆中的对象是全局可以被访问的，然而栈内存不能被其他线程所访问。
4、栈中的内存管理使用LIFO（后进先出）的方式完成，而堆内存的管理要更复杂了，因为它是全局被访问的。堆内存被分为，年轻一代，老一代等等。
5、栈内存是生命周期很短的，然而堆内存的生命周期从程序的运行开始到运行结束。
6、我们可以使用-Xms和-Xmx JVM选项定义开始的大小和堆内存的最大值，我们可以使用-Xss定义栈的大小
7、当栈内存满的时候，Java抛出java.lang.StackOverFlowError异常而堆内存满的时候抛出java.lang.OutOfMemoryError: Java Heap Space错误
8、和堆内存比，栈内存要小的多，因为明确使用了内存分配规则（LIFO），和堆内存相比栈内存非常快。

* 什么是深拷贝和浅拷贝
**答：**浅拷贝只是增加了一个引用指向已经存在的内存，而深拷贝就是增加一个引用并且申请一个新的内存，使这个增加的引用指向这个新的内存

* 手写链表逆序代码
**答：**
~~~ java
public Node Reverse(Node head) {
    if(head==null || head.next==null) return head;
    Node p1 = head;
    Node p2 = head.next;
    Node p3 = p2.next;
    p1.next = null;
    while(p3 != null) {
        p2.next = p1;
        p1 = p2;
        p2 = p3;
        p3 = p3.next;
    }
    p2.next = p1;
    return p2;
}
~~~

* 讲一下对树，B+树的理解
**答：**[点这里](https://www.cnblogs.com/George1994/p/7008732.html)

* 讲一下对图的理解
**答：**不理解不理解[了解](http://www.cnblogs.com/skywang12345/p/3691463.html)

* 判断单链表成环与否？
**答：**用两个引用从表头开始，一个步长为1一个步长为2，看是否会再次重合。

* 链表翻转（即：翻转一个单项链表）
**答：**

* 合并多个单有序链表（假设都是递增的）
**答：**[看这里](http://blog.csdn.net/joson793847469/article/details/52266416)

### 四、线程、多线程和线程池

* 开启线程的三种方式？
**答：**继承Thread重写run方法
实现Runnable接口
直接在函数体中使用匿名内部类

* 线程和进程的区别？
**答：**见上上面

* 为什么要有线程，而不是仅仅用进程？
**答：**

* run()和start()方法区别
**答：**start与run方法的主要区别在于当程序调用start方法一个新线程将会被创建，并且在run方法中的代码将会在新线程上运行，然而在你直接调用run方法的时候，程序并不会创建新线程，run方法内部的代码将在当前线程上运行。

* 如何控制某个方法允许并发访问线程的个数？
**答：**使用信号量Semaphore
当调用的时候请求一个信号（消费一个信号），如果信号被用完了则等待;
当调用结束释放一个信号，释放的信号新的线程就可以使用了

* 在Java中wait和sleep方法的不同；
**答：**wait属于Object,sleep属于Thread
wait会释放锁，sleep不会
wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用(使用范围)
sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常
[这里讲的不错](https://www.cnblogs.com/loren-Yang/p/7538482.html)

* 谈谈wait/notify关键字的理解
**答：**1.wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类，也就是每个对象都有wait( )，notify( )，notifyAll( ) 的功能，因为每个对象都有锁，锁是每个对象的基础，当然操作锁的方法也是最基础了。
2.当需要调用以上的方法的时候，一定要对竞争资源进行加锁，如果不加锁的话，则会报 IllegalMonitorStateException 异常
3.当想要调用wait( )进行线程等待时，必须要取得这个锁对象的控制权（对象监视器），一般是放到synchronized(obj)代码中。
4.在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知
5.调用obj.wait( )释放了obj的锁，否则其他线程也无法获得obj的锁，也就无法在synchronized(obj){ obj.notify() } 代码段内唤醒A。
6.notify( )方法只会通知等待队列中的第一个相关线程（不会通知优先级比较高的线程）
7.notifyAll( )通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）
8.假设有三个线程执行了obj.wait( )，那么obj.notifyAll( )则能全部唤醒tread1，thread2，thread3，但是要继续执行obj.wait（）的下一条语句，必须获得obj锁，因此，tread1，thread2，thread3只有一个有机会获得锁继续执行，例如tread1，其余的需要等待thread1释放obj锁之后才能继续执行。
9.当调用obj.notify/notifyAll后，调用线程依旧持有obj锁，因此，thread1，thread2，thread3虽被唤醒，但是仍无法获得obj锁。直到调用线程退出synchronized块，释放obj锁后，thread1，thread2，thread3中的一个才有机会获得锁继续执行

* 什么导致线程阻塞？
**答：**
A、线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行
B、线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。
C、线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。
D、线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。
[看看这里](http://blog.csdn.net/sinat_22013331/article/details/45740641)

* 线程如何关闭？
**答：**
1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 
2.使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。
3.使用interrupt方法中断线程。

* 讲一下java中的同步的方法
**答：**
1.同步方法
2.同步代码块
3.volatile
4.使用重入锁ReentrantLock
5.使用局部变量ThreadLocal实现
volatile和ThreadLoacl都是通过修饰线程共享的变量来实现同步

* 数据一致性如何保证？
**答：**
第一是悲观锁（独占锁），第二是乐观锁（可重入锁）。第一种锁独占锁是一种阻塞情况最为严重的方式，就是给数据加上独占锁，其他线程想写这个数据的话就会被挂起，只有获取这个数据的线程才有权限写入这个数据，这样的话就存在大量线程挂起，和竞争锁的情况对于cpu是极大的消耗，效率低下。 
第二种是给数据添加一个版本标识，每当有线程对其进行修改那么就把版本加一，这样当线程进行非原子操作的时候，一开始就保存了版本号，进行到修改数据的时候比较一下最新的版本号和久版本号是否一样，一样就修改不一样就重试（次数重试和时间重试两种）。 

* 如何保证线程安全？
**答：**
不跨线程共享变量
使状态变量为不可变的
在任何访问状态变量的时候使用同步。
每个共享的可变变量都需要由唯一一个确定的锁保护

* 如何实现线程同步？
**答：**同上？

* 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？
**答：**

* 线程间操作List
**答：**使用Collections.synchronizedList或者CopyOnWriteArrayList

* Java中对象的生命周期
**答：**创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）
强引用：只要引用存在，垃圾回收器永远不会回收
软引用：只有当内存不够的时候，才回收这类内存，因此在内存足够的时候，它们通常不被回收，需要通过算法检查是否回收Soft引用对象
弱引用：是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null
虚引用：是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用

* Synchronized用法
**答：**普通同步方法，锁是当前实例对象
静态同步方法，锁是当前类的class对象
同步方法块，锁是括号里面的对象
A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 
C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的
